# 中间件

[Fetch MDN]: https://developer.mozilla.org/en-US/docs/Web/API/Fetch
[Headers MDN]: https://developer.mozilla.org/en-US/docs/Web/API/Headers
[Response MDN]: https://developer.mozilla.org/en-US/docs/Web/API/Response
[FormData MDN]: https://developer.mozilla.org/en-US/docs/Web/API/FormData
[URL MDN]: https://developer.mozilla.org/en-US/docs/Web/API/URL

中间件是 Keq 最强大的特性之一，它让你能够以优雅的方式扩展和定制 HTTP 请求的行为。Keq 采用了与 [Koa](https://github.com/koajs/koa) 相似的洋葱模型中间件架构。

## 为什么需要中间件？

在使用原生 [Fetch API][Fetch MDN] 时，我们经常需要各种功能增强，比如自动重试、超时控制、错误处理等。NPM 上有很多这类库，如 [`fetch-retry`](https://www.npmjs.com/package/fetch-retry)、[`node-fetch-har`](https://www.npmjs.com/package/node-fetch-har) 等，它们通常提供 `wrap(fetch)` 式的 API。

这种方式有两个问题：

1. **难以组合**：多个功能需要层层嵌套，像 `wrapX(wrapY(wrapZ(fetch)))`，代码难以维护
2. **缺乏灵活性**：难以为不同的 API 路由配置不同的行为

Keq 的中间件模型优雅地解决了这些问题。

## 洋葱模型

![Keq Middleware](/img/keq_middleware.png)

Keq 的中间件采用洋葱模型：请求从外层中间件进入，层层向内传递直到发送请求，然后响应再从内向外返回，每层中间件都有机会处理请求和响应。

Keq 内置了 3 层核心中间件（由外到内）：

1. **flowControlMiddleware** - 提供并发控制功能
2. **timeoutMiddleware** - 提供请求超时控制
3. **fetchMiddleware** - 使用 [Fetch API][Fetch MDN] 发送实际请求

## 编写中间件

### 基础概念

中间件是一个接收 `context` 和 `next` 两个参数的异步函数：

```typescript
import { KeqMiddleware } from "keq"

const myMiddleware: KeqMiddleware = async (context, next) => {
  // 在这里可以修改请求参数
  console.log("请求发送前")

  await next() // 调用下一层中间件

  // 在这里可以处理响应
  console.log("请求完成后")
}
```

**参数说明**：

- **context** - 请求上下文，包含请求参数、响应结果等所有信息
- **next** - 调用下一层中间件的函数

### 示例：错误处理中间件

让我们从一个简单的例子开始，编写一个检查响应状态码的中间件：

```typescript
import { request } from "keq"

request.use(async (context, next) => {
  await next() // 先执行请求

  // 检查响应状态
  if (context.response && context.response.status !== 200) {
    throw new Error(`请求失败: ${context.response.status}`)
  }
})

try {
  await request.get("http://example.com/cats")
} catch (err) {
  console.error(err) // 捕获非 200 状态码的错误
}
```

### 路由中间件

在实际项目中，不同的 API 可能需要不同的处理逻辑。Keq 提供了强大的路由功能，让中间件只对特定请求生效：

```typescript
import { request } from "keq"

request
  .useRouter()
  .host("api.example.com", async (context, next) => {
    // 仅对 api.example.com 域名生效
    context.request.headers.set("X-API-Version", "v1")
    await next()
  })
  .pathname("/admin/**", async (context, next) => {
    // 仅对 /admin/* 路径生效
    context.request.headers.set("Authorization", "Bearer admin-token")
    await next()
  })
```

### 可复用的中间件

将中间件封装成函数，可以在多处复用并接受配置参数：

```typescript
import { KeqMiddleware, request } from "keq"

// 创建一个添加认证头的中间件工厂函数
function authMiddleware(token: string): KeqMiddleware {
  return async (context, next) => {
    context.request.headers.set("Authorization", `Bearer ${token}`)
    await next()
  }
}

// 创建一个日志中间件
function logMiddleware(prefix: string): KeqMiddleware {
  return async (context, next) => {
    const startTime = Date.now()
    console.log(`${prefix} 请求开始:`, context.request.url.href)

    await next()

    const duration = Date.now() - startTime
    console.log(`${prefix} 请求完成:`, context.response?.status, `耗时: ${duration}ms`)
  }
}

// 应用中间件
request
  .useRouter()
  .host("api.example.com", authMiddleware("my-secret-token"))
  .pathname("/api/**", logMiddleware("[API]"))
```

### 添加自定义选项

中间件可以通过 TypeScript 模块扩展添加自定义选项，让使用者在调用时灵活控制行为：

```typescript
import { KeqMiddleware, request } from "keq"

// 扩展类型定义
declare module "keq" {
  interface KeqOptions<T> {
    silent(value: boolean): Keq<T>
  }
}

// 创建支持 silent 选项的中间件
function errorHandlerMiddleware(): KeqMiddleware {
  return async (context, next) => {
    await next()

    if (context.response && context.response.status >= 400) {
      // 读取自定义选项
      if (!context.options.silent) {
        alert(`请求失败: ${context.response.status}`)
      }
      throw new Error(`HTTP ${context.response.status}`)
    }
  }
}

request.use(errorHandlerMiddleware())

// 正常情况会弹出 alert
await request.get("/cats")

// 使用 silent 选项，不会弹出 alert
await request.get("/cats").option("silent", true)
```

## 路由方法

`.useRouter()` 提供了多种路由匹配方式：

| 方法 | 描述 | 示例 |
|:-----|:-----|:-----|
| `.host(host, ...middlewares)` | 匹配特定域名 | `.host("api.example.com", authMiddleware())` |
| `.pathname(pattern, ...middlewares)` | 匹配路径模式（支持 glob 和正则） | `.pathname("/api/**", logMiddleware())` |
| `.method(method, ...middlewares)` | 匹配 HTTP 方法 | `.method("POST", validateMiddleware())` |
| `.module(name, ...middlewares)` | 匹配模块名（配合 `@keq-request/cli` 使用） | `.module("userService", errorHandler())` |
| `.location(...middlewares)` | 匹配当前域名（浏览器为 `window.location.origin`，Node.js 为 `127.0.0.1`） | `.location(localMiddleware())` |
| `.route(...middlewares)` | 自定义路由条件 | `.route(customMatcher)` |

**路由示例**：

```typescript
import { request } from "keq"

request
  .useRouter()
  // 为所有 example.com 的请求添加认证
  .host("example.com", authMiddleware("token-1"))
  // 为 /admin 路径下的请求添加额外认证
  .pathname("/admin/**", adminAuthMiddleware())
  // 为所有 POST 请求添加日志
  .method("POST", logMiddleware("[POST]"))
  // 为通过 CLI 生成的 userService 模块添加错误处理
  .module("userService", errorHandlerMiddleware())
```

## Context 对象

`context` 是中间件的核心，包含了请求的所有信息。

### 主要属性

| 属性 | 描述 |
|:-----|:-----|
| `context.request` | HTTP 请求参数（URL、方法、请求头、请求体等） |
| `context.response` | HTTP 响应代理对象，可多次读取响应体 |
| `context.res` | 原始 Fetch Response 对象 |
| `context.options` | 通过 `.option()` 设置的自定义选项 |
| `context.output` | 设置请求的返回值（当未使用 `.resolveWith()` 时） |
| `context.data` | 请求级别的共享数据，在请求完成后自动清理 |
| `context.global` | 全局共享数据，不会随请求结束而销毁 |
| `context.orchestration` | 中间件编排器，提供中间件执行状态和 fork 能力，详见[进阶 - 中间件编排器](./advanced/middleware-orchestrator#contextorchestration-属性详解) |
| `context.locationId` | **只读** 请求代码的位置标识（文件路径+行号） |

### context.request

包含发送 HTTP 请求所需的所有参数：

| 属性 | 描述 |
|:-----|:-----|
| `context.request.url` | 请求 [URL][URL MDN] |
| `context.request.__url__` | **只读** 合并了路由参数后的完整请求 [URL][URL MDN] |
| `context.request.method` | HTTP 方法（'get', 'post', 'put', 'patch', 'delete', 'head'） |
| `context.request.headers` | 请求头（[Headers][Headers MDN] 对象） |
| `context.request.body` | 请求体 |
| `context.request.routeParams` | 路由参数对象 |
| `context.request.abort()` | 中止当前请求 |
| `context.request.credentials` | [Fetch API][Fetch MDN] 的 credentials 选项 |
| `context.request.mode` | [Fetch API][Fetch MDN] 的 mode 选项 |
| `context.request.cache` | [Fetch API][Fetch MDN] 的 cache 选项 |
| `context.request.redirect` | [Fetch API][Fetch MDN] 的 redirect 选项 |
| `context.request.referrer` | [Fetch API][Fetch MDN] 的 referrer 选项 |
| `context.request.referrerPolicy` | [Fetch API][Fetch MDN] 的 referrerPolicy 选项 |
| `context.request.integrity` | [Fetch API][Fetch MDN] 的 integrity 选项 |
| `context.request.keepalive` | [Fetch API][Fetch MDN] 的 keepalive 选项 |

### context.options

内置选项及其默认值：

| 选项 | 默认值 | 描述 |
|:-----|:------|:-----|
| `context.options.fetchAPI` | `global.fetch` | 用于发送请求的 [Fetch API][Fetch MDN] 实现 |
| `context.options.resolveWith` | `"intelligent"` | 响应体解析方式 |
| `context.options.retry.times` | `undefined` | 重试次数 |
| `context.options.retry.delay` | `undefined` | 重试延迟时间（毫秒） |
| `context.options.retry.on` | `undefined` | 自定义重试条件函数 |
| `context.options.timeout` | `undefined` | 请求超时时间（毫秒） |
| `context.options.flowControl` | `undefined` | 并发控制模式 |
| `context.options.module` | `undefined` | 模块元信息（name、pathname、method），通常由 `@keq-request/cli` 自动生成 |

### context.response

`context.response` 是原始 [Response][Response MDN] 对象的代理，解决了 [Response][Response MDN] 对象的方法（如 `.json()`、`.text()`）只能调用一次的限制，允许多个中间件安全地读取响应体。

```typescript
const middleware: KeqMiddleware = async (context, next) => {
  await next()

  // 多个中间件都可以安全地读取 JSON
  const data = await context.response?.json()
  console.log(data)
}
```

### context.data

`context.data` 是一个对象，用于在同一请求的多个中间件之间共享数据。与 `context.global` 不同，`context.data` 会在请求完成后自动清理，无需手动管理。

**使用场景：**

- 在中间件之间传递临时数据（如计时、追踪信息等）
- 存储请求处理过程中的中间状态
- 由中间件内部使用，对调用者透明

```typescript
import { KeqMiddleware, KeqContext } from 'keq'

// 在一个中间件中设置数据
const setDataMiddleware: KeqMiddleware = async (context: KeqContext, next) => {
  context.data.startTime = Date.now()
  context.data.userId = '12345'
  await next()
}

// 在另一个中间件中读取数据
const readDataMiddleware: KeqMiddleware = async (context: KeqContext, next) => {
  await next()

  const duration = Date.now() - context.data.startTime
  console.log(`用户 ${context.data.userId} 的请求耗时: ${duration}ms`)
}
```

:::tip context.data vs context.options
- **context.data**：中间件内部使用，用于中间件之间传递数据，调用者无需关心
- **context.options**：调用者控制，通过 `.option()` 方法设置，用于向中间件传递配置

推荐使用 `context.data` 而不是 `context.global` 来存储请求级别的临时数据，避免内存泄漏。
:::

:::tip
关于 Context 的类型体系（`KeqContext`、`KeqSharedContext`、`KeqExecutionContext`）和 `context.orchestration` 的详细说明，请参考[进阶 - 中间件编排器](./advanced/middleware-orchestrator)。
:::

## 创建独立实例

使用 `new KeqRequest()` 可以创建独立的请求实例，不同实例之间的中间件(`Middleware`)、全局状态(`context.global`)完全隔离：

```typescript
import { KeqRequest } from "keq"

const internalAPI = new KeqRequest({
  baseOrigin: "http://internal-api.company.com"
})

const externalAPI = new KeqRequest({
  baseOrigin: "https://api.example.com"
})

// 两个实例即使使用相同的 key，并发控制队列也是独立的
await Promise.all([
  internalAPI.get("/users").flowControl("serial", "api-key"),
  externalAPI.get("/data").flowControl("serial", "api-key"), // 与 internalAPI 独立，不会阻塞
])
```

**KeqRequest 构造函数选项**：

| 选项 | 描述 |
|:-----|:-----|
| `baseOrigin` | 默认的请求域名（浏览器默认为 `window.location.origin`，Node.js 默认为 `http://127.0.0.1`） |
| `initMiddlewares` | 自定义内置中间件（高级用法，一般不需要修改） |

:::tip
从 `keq` 导入的 `request` 对象是一个默认的 `KeqRequest` 实例。
:::

## 最佳实践

### 1. 中间件职责单一

每个中间件应该只负责一个功能，便于理解和复用：

```typescript
// ✅ 好的做法：功能单一
function authMiddleware(token: string): KeqMiddleware { /* ... */ }
function logMiddleware(): KeqMiddleware { /* ... */ }

// ❌ 不好的做法：功能混杂
function megaMiddleware(): KeqMiddleware {
  // 既做认证，又做日志
}
```

### 2. 谨慎使用 context.global

`context.global` 中的数据不会自动清理,使用后应及时删除以避免内存泄漏。

```typescript
const key = Symbol('myMiddleware')

const middleware: KeqMiddleware = async (context, next) => {
  context.global[key] = { startTime: Date.now() }

  try {
    await next()
  } finally {
    // 及时清理
    delete context.global[key]
  }
}
```
