# 响应体序列化

响应体序列化控制如何处理 HTTP 响应的 body 数据。Keq 提供了多种序列化方式，可以根据实际需求灵活选择。

## 基本用法

使用 `.resolveWith(type)` 方法指定响应体的序列化方式：

```typescript
import { request } from "keq"

const response = await request
  .get("/api/cats/1")
  .resolveWith("json")

console.log(response.name)
```

## 序列化类型

### intelligent（默认）

自动序列化模式会根据实际情况自动选择最佳的处理方式：

1. 如果中间件设置了 `context.output`，则直接返回该值
2. 否则，根据响应的 `Content-Type` 自动选择序列化方式

import IntelligentTable from '../components/_intelligent-table.mdx'

<IntelligentTable />


```typescript
import { request } from "keq"

// 根据 Content-Type 自动处理
const cat = await request.get("/api/cats/1")
// Content-Type: application/json → 自动解析为对象
// Content-Type: text/plain → 返回字符串
```

:::tip 推荐
对于大多数场景，使用默认的 `intelligent` 模式即可，它能智能处理各种响应类型。
:::

### json

将响应体解析为 JSON 对象：

```typescript
import { request } from "keq"

interface Cat {
  id: number
  name: string
  breed: string
}

const cat = await request
  .get("/api/cats/1")
  .resolveWith("json") as Cat

console.log(`${cat.name} is a ${cat.breed}`)
```

### text

将响应体解析为纯文本字符串：

```typescript
import { request } from "keq"

const description = await request
  .get("/api/cats/1/description")
  .resolveWith("text")

console.log(description)
```

### blob

将响应体解析为 [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob) 对象，适合处理文件下载：

```typescript
import { request } from "keq"

const imageBlob = await request
  .get("/api/cats/1/photo")
  .resolveWith("blob")

// 创建下载链接
const url = URL.createObjectURL(imageBlob)
const link = document.createElement("a")
link.href = url
link.download = "cat-photo.jpg"
link.click()

// 清理 URL
URL.revokeObjectURL(url)
```

### array-buffer

将响应体解析为 [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)，适合处理二进制数据：

```typescript
import { request } from "keq"

const buffer = await request
  .get("/api/cats/1/audio")
  .resolveWith("array-buffer")

// 使用 Web Audio API 播放音频
const audioContext = new AudioContext()
const audioBuffer = await audioContext.decodeAudioData(buffer)
const source = audioContext.createBufferSource()
source.buffer = audioBuffer
source.connect(audioContext.destination)
source.start()
```

### form-data

将响应体解析为 [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) 对象：

```typescript
import { request } from "keq"

const formData = await request
  .get("/api/cats/1/form")
  .resolveWith("form-data")

console.log(formData.get("name"))
console.log(formData.get("breed"))
```

### response

返回原始的 [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) 对象，可以完全控制响应的处理方式：

```typescript
import { request } from "keq"

const response = await request
  .get("/api/cats/1")
  .resolveWith("response")

console.log(response.status)
console.log(response.headers.get("content-type"))

// 手动解析响应体
const cat = await response.json()
console.log(cat.name)
```
